<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">
<link rel="import" href="../api-url-data-model/api-url-data-model.html">
<link rel="import" href="../api-url-editor/api-url-editor.html">
<link rel="import" href="../api-url-params-editor/api-url-params-editor.html">
<link rel="import" href="../authorization-panel/authorization-panel.html">
<link rel="import" href="../api-headers-editor/api-headers-editor.html">
<link rel="import" href="../api-body-editor/api-body-editor.html">
<link rel="import" href="../raml-aware/raml-aware.html">
<link rel="import" href="../paper-tabs/paper-tabs.html">
<link rel="import" href="../paper-tabs/paper-tab.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-pages/iron-pages.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<link rel="import" href="../api-form-mixin/api-form-styles.html">
<dom-module id="api-request-editor">
  <template>
    <style include="api-form-styles">
    :host {
      display: block;
    }

    .content {
      height: 100%;
      @apply --layout-vertical;
      @apply --api-request-editor-container;
    }

    [hidden] {
      display: none !important;
    }

    .panel-warning {
      width: 16px;
      height: 16px;
      margin-left: 4px;
      color: var(--warning-primary-color, #FF7043);
    }

    .url-invalid-info {
      @apply --arc-font-body1;
      color: var(--error-color);
    }

    paper-spinner {
      margin-right: 8px;
    }

    iron-pages > * {
      border: 1px var(--api-request-editor-editors-border-color, transparent) solid;
      min-height: 120px;
    }

    .action-bar {
      @apply --layout-horizontal;
      @apply --layout-end-justified;
      @apply --layout-center;
      margin-top: 8px;
    }

    .send-button {
      background-color: var(--primary-button-background-color, var(--accent-color));
      color: var(--primary-button-color, #fff);
      @apply --action-button;
    }

    .send-button:hover {
      background-color: var(--primary-button-hover-background-color, var(--accent-color));
      color: var(--primary-button-hover-color, #fff);
      @apply --action-button-hover;
    }

    .send-button[disabled] {
      background-color: var(--action-button-disabled-background-color, rgb(234, 234, 234));
      color: var(--action-button-disabled-color, #a8a8a8);
    }

    .url-editor {
      @apply --layout-horizontal;
      @apply --layout-center;
    }

    api-url-editor {
      @apply --layout-flex;
    }

    :host([narrow]) .content {
      @apply --layout-vertical;
      @apply --api-request-editor-container-narrow;
    }

    :host([narrow]) api-url-editor {
      width: auto;
    }
    </style>
    <template is="dom-if" if="[[aware]]">
      <raml-aware raml="{{amfModel}}" scope="[[aware]]"></raml-aware>
    </template>
    <api-url-data-model
      aware="[[aware]]"
      endpoint-path="{{endpointPath}}"
      api-base-uri="{{apiBaseUri}}"
      selected="[[selectedAmfId]]"
      path-model="{{pathModel}}"
      query-model="{{queryModel}}"></api-url-data-model>

    <div class="content">
      <div class="url-editor" hidden$="[[noUrlEditor]]">
        <api-url-editor
          required
          auto-validate
          invalid="{{urlInvalid}}"
          base-uri="[[_computeFinaleBaseUri(apiBaseUri,baseUri)]]"
          endpoint-path="[[endpointPath]]"
          query-model="{{queryModel}}"
          path-model="{{pathModel}}"
          value="{{url}}"></api-url-editor>
      </div>
      <paper-tabs selected="{{selectedTab}}">
        <paper-tab hidden$="[[authNotRequired]]">
          Authorization
          <iron-icon icon="arc:warning" class="panel-warning" hidden$="[[authValid]]" title="Fill up missing auth data"></iron-icon>
        </paper-tab>
        <paper-tab>Parameters</paper-tab>
        <paper-tab>Headers</paper-tab>
        <paper-tab hidden$="[[!isPayloadRequest]]">Body</paper-tab>
      </paper-tabs>
      <iron-pages selected="{{selectedTab}}">
        <authorization-panel hidden$="[[authNotRequired]]" secured-by="[[securedBy]]" redirect-uri="[[redirectUri]]" auth-required="{{authRequired}}" auth-valid="{{authValid}}"></authorization-panel>
        <api-url-params-editor uri-model="{{pathModel}}" query-model="{{queryModel}}" narrow="[[narrow]]" allow-custom="[[allowCustom]]"></api-url-params-editor>
        <api-headers-editor amf-headers="[[apiHeaders]]" narrow="[[narrow]]" content-type="{{contentType}}" is-payload="[[isPayloadRequest]]" value="{{headers}}" narrow="[[narrow]]" allow-custom="[[allowCustom]]" allow-disable-params="[[allowDisableParams]]" allow-hide-optional="[[allowHideOptional]]"></api-headers-editor>
        <api-body-editor amf-model="[[apiPayload]]" narrow="[[narrow]]" hidden$="[[!isPayloadRequest]]" content-type="{{contentType}}" value="{{payload}}" narrow="[[narrow]]" allow-custom="[[allowCustom]]" allow-disable-params="[[allowDisableParams]]" allow-hide-optional="[[allowHideOptional]]"></api-body-editor>
      </iron-pages>
      <div class="action-bar">
        <paper-spinner alt="Loading contacts list" active="[[loadingRequest]]"></paper-spinner>
        <span class="url-invalid-info" hidden$="[[!urlInvalid]]">Request URL is invalid.</span>
        <paper-button class="send-button" on-tap="execute" hidden$="[[!authValid]]" disabled="[[urlInvalid]]">Send</paper-button>
        <template is="dom-if" if="[[!authValid]]">
          <paper-button class="send-button" on-tap="authAndExecute" disabled="[[urlInvalid]]">Authorize and send</paper-button>
        </template>
      </div>
    </div>
    <paper-toast text="Authorization for this endpoint is required" id="authFormError" horizontal-align="right" horizontal-offset="12"></paper-toast>
  </template>
  <script>
  (function() {
    const RAML_VOC = 'http://raml.org/vocabularies/';
    const VOC_DOC = RAML_VOC + 'document#';
    const VOC_HTTP = RAML_VOC+ 'http#';
    const HYD_CORE = 'http://www.w3.org/ns/hydra/core#';
    /**
     * `api-request-editor`
     * A request editor that builds the UI based on AMF model or presents default empty editor.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class ApiRequestEditor extends Polymer.Element {
      static get is() { return 'api-request-editor'; }
      static get properties() {
        return {
          /**
           * `raml-aware` scope property to use.
           */
          aware: String,
          /**
           * AMF HTTP method (operation in AMF vocabulary) ID.
           */
          selectedAmfId: String,
          /**
           * AMF API model.
           * The element extracts method definition from passed model
           * and by using `selectedAmfId`.
           */
          amfModel: Object,
          _methodModel: {
            type: Object,
            computed: '_computeMethodModel(amfModel, selectedAmfId)'
          },
          /**
           * Hides the URL editor from the view.
           * The editor is still in the DOM and the `urlInvalid` property still will be set.
           */
          noUrlEditor: Boolean,
          /**
           * A base URI for the API. To be set if RAML spec is missing `baseUri`
           * declaration and this produces invalid URL input. This information
           * is passed to the URL editor that prefixes the URL with `baseUri` value
           * if passed URL is a relative URL.
           */
          baseUri: String,
          /**
           * Computed from AMF model for the metod HTTP method name.
           *
           * @type {String}
           */
          httpMethod: {
            type: Boolean,
            value: false,
            computed: '_computeHttpMethod(_methodModel)'
          },
          /**
           * Headers for the request.
           *
           * @type {String|undefined}
           */
          headers: {
            type: String,
            notify: true
          },
          /**
           * Body for the request. The type of the body depends on
           * defined in the API media type.
           *
           * @type {String|FormData|File}
           */
          payload: {
            type: String,
            notify: true
          },
          /**
           * Final request URL including settings like `baseUri`, AMF
           * model settings and user provided parameters.
           * This value is always compoted by `api-url-editor` even if it's
           * hidden from the view.
           */
          url: {
            type: String,
            notify: true
          },
          /**
           * Selected request tab.
           */
          selectedTab: {
            type: Number,
            value: 0,
            notify: true,
            observer: '_selectedTabChanged'
          },
          /**
           * Current content type.
           *
           * @type {String|undefined}
           */
          contentType: {
            type: String,
            notify: true
          },
          /**
           * Computed value of security scheme from selected method.
           *
           * @type {Array<Object>}
           */
          securedBy: {
            type: Array,
            computed: '_computeSecuredBy(_methodModel)'
          },
          /**
           * Computed list of headers in the AMF model
           *
           * @type {Array<Object>}
           */
          apiHeaders: {
            type: Array,
            computed: '_computeHeaders(_methodModel)'
          },
          /**
           * Defined by the API payload data.
           *
           * @type {Array<Object>|undefined}
           */
          apiPayload: {
            type: Array,
            computed: '_computeApiPayload(_methodModel)'
          },
          /**
           * Computed value if the method can carry a payload.
           */
          isPayloadRequest: {
            type: Boolean,
            value: false,
            computed: '_computeIsPayloadRequest(httpMethod)'
          },
          /**
           * OAuth2 redirect URI.
           * This value **must** be set in order for OAuth 1/2 to work properly.
           */
          redirectUri: String,
          /**
           * Inheritet from the authorization panel state if authorization is
           * required. Authorization may be not required if one of the
           * authorization methods is `nil` (RAML).
           */
          authRequired: Boolean,
          /**
           * Inheritet from the authorization panel state if authorization
           * data is valid.
           */
          authValid: {
            type: Boolean,
            observer: '_authValidChanged'
          },
          /**
           * If set it will renders the view in the narrow layout.
           */
          narrow: {
            type: Boolean,
            notify: true,
            reflectToAttribute: true
          },
          /**
           * Computed value of if authorization is required for the endpoint.
           * If the auth is not required then the authorization tab is removed
           * from the view.
           */
          authNotRequired: {
            type: Boolean,
            computed: '_computeNoAuth(securedBy)',
            observer: '_noAuthChanged'
          },
          /**
           * Flag set when the request is being made.
           */
          loadingRequest: {
            type: Boolean,
            notify: true,
            readOnly: true
          },
          /**
           * If set it computes `hasOptional` property and shows checkbox in the
           * form to show / hide optional properties.
           */
          allowHideOptional: Boolean,
          /**
           * If set, enable / disable param checkbox is rendered next to each
           * form item.
           */
          allowDisableParams: Boolean,
          /**
           * When set, renders "add custom" item button.
           * If the element is to be used withouth AMF model this should always
           * be enabled. Otherwise users won't be able to add a parameter.
           */
          allowCustom: Boolean
        };
      }
      /**
       * Computes base URI passed to the URL editor.
       *
       * @param {String} apiBaseUri Computed from AMF base uri
       * @param {?String} customBaseUri Base URI that overrides api base uri
       * @return {String} `customBaseUri` if present or `apiBaseUri`
       */
      _computeFinaleBaseUri(apiBaseUri, customBaseUri) {
        if (customBaseUri) {
          return customBaseUri;
        }
        return apiBaseUri;
      }
      /**
       * Computes method model from the AMF model
       *
       * @param {[type]} api [description]
       * @return {[type]} [description]
       */
      _computeMethodModel(api, id) {
        if (!id) {
          return;
        }
        if (!api) {
          return;
        }
        const endpointId = this.computeEndpointId(id);
        const endpoint = this.findEndpoint(endpointId, api);
        if (!endpoint) {
          return;
        }
        if (endpointId === id) {
          return;
        }
        return this.findMethod(id, endpoint[HYD_CORE + 'supportedOperation']);
      }
      /**
       * Computes endpoint `@id` for given `id`.
       * On a base level it subrtacts the last part after `/` which
       * is a delimiter between endpoint identifier and method name.
       *
       * @param {String} id Object ID. Can be operation's or endpoint's ID.
       * @return {String} Endpoint id. It may return the same value if passed
       * id is endpoint ID.
       */
      computeEndpointId(id) {
        if (!id) {
          throw new Error('Argument "id" is required.');
        }
        const parts = id.split('/');
        if (parts[parts.length - 1][0] === '%') {
          return id;
        }
        parts.pop();
        return parts.join('/');
      }
      /**
       * Finds an endpoint definition in the API.
       *
       * @param {String} endpointId Endpoint `@id` from AMF model
       * @param {?Object} api AMD model for the api. If not set, `webApi` property
       * is used.
       * @return {Object} Definition of the endpoint.
       */
      findEndpoint(endpointId, api) {
        if (api instanceof Array) {
          api = api[0];
        }
        if (!this._modelHasType(api, VOC_DOC + 'Document')) {
          return;
        }
        const encodes = api[VOC_DOC + 'encodes'];
        api = encodes.find((item) => this._modelHasType(item, 'http://schema.org/WebAPI'));
        if (!api) {
          return;
        }
        api = api[VOC_HTTP + 'endpoint'];
        if (!api) {
          return;
        }
        return api.find((item) => item['@id'] === endpointId);
      }
      /**
       * Finds a method definition on the list of operations for an endpoint.
       *
       * @param {String} id ID of the operation (method)
       * @param {Array<Object>} operations List of endpoint's operations.
       * @return {Object|undefined} Method definition.
       */
      findMethod(id, operations) {
        if (!id || !operations || !operations.length) {
          return;
        }
        return operations.find((item) => item['@id'] === id);
      }

      /**
       * Checks if a model has a type.
       * @param {Object} model Model to test
       * @param {String} type Type name
       * @return {Boolean} True if model has a type.
       */
      _modelHasType(model, type) {
        const types = model['@type'] || [];
        const index = types.findIndex((item) => item === type);
        return index !== -1;
      }
      /**
       * Computes AMF model for authorization panel.
       *
       * @param {Object} model Current method model.
       * @return {Array|undefined} List of security definitions for the endpoint.
       */
      _computeSecuredBy(model) {
        return model && model[RAML_VOC + 'security#security'];
      }
      /**
       * Computes model definition for headers.
       *
       * @param {?Object} model Method model
       * @return {Array|undefined} List of headers or undefined.
       */
      _computeHeaders(model) {
        if (!model) {
          return;
        }
        model = model[HYD_CORE + 'expects'];
        if (!model) {
          return;
        }
        model = model[0];
        return model[VOC_HTTP + 'header'];
      }
      /**
       * Computes if authorization for the endpoint is set.
       *
       * @param {Object} model Operation model.
       * @return {Boolean}
       */
      _computeNoAuth(model) {
        return !(model && model[0]);
      }
      /**
       * Computes value for `httpMethod` property from AMF model for current
       * operation.
       *
       * @param {Object} model Operation model.
       * @return {String} Method name.
       */
      _computeHttpMethod(model) {
        const value = model[HYD_CORE + 'method'];
        return value && value[0]['@value'];
      }
      /**
       * Computes value for `apiPayload` property from AMF model for current
       * method.
       *
       * @param {Object} model Operation model.
       * @return {Array<Object>|undefined} Method payload.
       */
      _computeApiPayload(model) {
        if (!model) {
          return;
        }
        model = model[HYD_CORE + 'expects'];
        if (!model) {
          return;
        }
        model = model[0];
        return model[VOC_HTTP + 'payload'];
      }
      /**
       * Computes value for `isPayloadRequest`.
       * Only `GET` and `HEAD` methods are known as ones that can't carry a
       * payload. For any other HTTP method this always returns true.
       *
       * @param {String} method HTTP method value
       * @return {Boolean}
       */
      _computeIsPayloadRequest(method) {
        return ['get', 'head'].indexOf(method) === -1;
      }
      /**
       * Updates tabs selection when `authNotRequired` property change.
       * It changes selection to the next tab if there's no authorization
       * and current selected editor is authorization.
       *
       * @param {Boolean} value Current value for `authNotRequired`
       */
      _noAuthChanged(value) {
        if (!value && this.selectedTab === 2) {
          this.selectedTab = 0;
        } else if (value && this.selectedTab === 0) {
          this.selectedTab = 1;
        }
        this._refreshTabs();
        this._analyticsEvent('no-auth-changed', String(value));
      }
      /**
       * Updates the state of the body editor when switching to it.
       * Code mirror does not property calculate it's value when
       * the editor is not visible. This forces to refresh the value of the
       * editor.
       *
       * @param {Number} selected Selected tam index.
       */
      _selectedTabChanged(selected) {
        if (selected === 3) {
          Polymer.RenderStatus.afterNextRender(this, () => {
            this.shadowRoot.querySelector('api-body-editor').currentPanel.refresh();
          });
        }
        this._analyticsEvent('tab-changed', selected);
      }

      /**
       * Refreshes tabs selection. To be called when number of tabs changes.
       */
      _refreshTabs() {
        const tabs = this.shadowRoot && this.shadowRoot.querySelector('paper-tabs');
        if (!tabs) {
          return;
        }
        tabs.notifyResize();
      }
      /**
       * Dispatches analytics event.
       * @param {String} action Event action
       * @param {String} label Event label
       */
      _analyticsEvent(action, label) {
        const e = new CustomEvent('send-analytics', {
          detail: {
            type: 'event',
            category: ApiRequestEditor.is,
            action: action,
            label: label
          },
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(e);
      }

      authAndExecute() {
        this.__requestAuthAwaiting = true;
        if (this.selectedTab !== 0) {
          this.selectedTab = 0;
        }
        this.$.authFormError.opened = true;
      }

      execute() {
        this._setLoadingRequest(true);
        const e = new CustomEvent('api-request', {
          cancelable: true,
          bubbles: true,
          composed: true,
          detail: this.serializeRequest()
        });
        this.dispatchEvent(e);
      }

      _authValidChanged(valid) {
        if (!valid) {
          return;
        }
        if (this.__requestAuthAwaiting) {
          this.execute();
        }
      }

      /**
       * Returns an object with the request properties.
       * The object contains:
       * - method (String)
       * - url (String)
       * - headers (String)
       * - payload (String)
       * - auth (Object)
       *
       * The `auth` property is optional and is only added to the request if simple `authorization`
       * header will not work. For example NTLM auth method has to be made on a single socket
       * connection (authorization and the request) so it can't be made before the request.
       *
       * The `auth` object contains 2 properties:
       * - type (String) the authorization type - one of from the `auth-methods` element
       * - settings (Object) Authorization parameters entered by the user. It vary and depends on
       * selected auth method. For example in case of the NTLM it will be: `username`, `password` and
       * `domain`.
       */
      serializeRequest() {
        const result = {
          method: (this.httpMethod || 'get').toUpperCase(),
          url: this.url,
          headers: this.headers,
          payload: this.payload
        };
        if (this.authMethod && this.authSettings) {
          result.auth = this.authSettings;
        }
        return result;
      }
    }

    window.customElements.define(ApiRequestEditor.is, ApiRequestEditor);
  })();
  </script>
</dom-module>
