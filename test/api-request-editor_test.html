<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>api-request-editor test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="amf-loader.js"></script>
  <link rel="import" href="../api-request-editor.html">
</head>
<body>
  <test-fixture id="Basic">
    <template>
      <api-request-editor></api-request-editor>
    </template>
  </test-fixture>
  <test-fixture id="NoUrl">
    <template>
      <api-request-editor no-url-editor></api-request-editor>
    </template>
  </test-fixture>
  <script>
  /* global AmfLoader */
  const API_ROOT = 'file://demo/api-raml/api.raml#/web-api/end-points/';
  suite('api-request-editor', () => {
    let amf;
    let element;
    suiteSetup(() => {
      return AmfLoader.load()
      .then((model) => amf = model);
    });

    suite('computeEndpointId()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
      });
      test('Renturns the same ID for endpoint ID', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.computeEndpointId(id);
        assert.equal(result, id);
      });

      test('Renturns endpoint id for method', () => {
        const compare = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.computeEndpointId(compare + '/get');
        assert.equal(result, compare);
      });

      test('Throws an error when no argument', () => {
        assert.throws(() => {
          element.computeEndpointId();
        });
      });
    });

    suite('findEndpoint()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
      });

      test('Finds endpoint by id', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.findEndpoint(id, amf);
        assert.typeOf(result, 'object');
        assert.equal(result['@id'], id);
      });

      test('Finds endpoint by id for API as an object', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.findEndpoint(id, amf[0]);
        assert.typeOf(result, 'object');
        assert.equal(result['@id'], id);
      });

      test('Returns undefined when not a Document', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.findEndpoint(id, {
          '@type': ['http://raml.org/vocabularies/document#Unit']
        });
        assert.isUndefined(result);
      });

      test('Returns undefined when no WebApi', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element.findEndpoint(id, {
          '@type': ['http://raml.org/vocabularies/document#Document'],
          'http://raml.org/vocabularies/document#encodes': [{
            '@type': ['http://raml.org/vocabularies/document#DomainElement']
          }]
        });
        assert.isUndefined(result);
      });
    });

    suite('_modelHasType()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
      });
      test('Checks when type exists', () => {
        const result = element._modelHasType(amf[0], 'http://raml.org/vocabularies/document#Fragment');
        assert.isTrue(result);
      });
      test('Checks when type does not exists', () => {
        const result = element._modelHasType(amf[0], 'http://raml.org/vocabularies/document#Something');
        assert.isFalse(result);
      });
    });

    suite('findMethod()', () => {
      const model = [{
        '@id': 'id1'
      }, {
        '@id': 'id2'
      }];
      suiteSetup(() => {
        element = fixture('Basic');
      });

      test('Finds method model by id', () => {
        let result = element.findMethod('id1', model);
        assert.typeOf(result, 'object');
        result = element.findMethod('id2', model);
        assert.typeOf(result, 'object');
      });

      test('Returns undefined when model is not found', () => {
        let result = element.findMethod('id3', model);
        assert.isUndefined(result);
      });

      test('Returns undefined when no id', () => {
        let result = element.findMethod('', model);
        assert.isUndefined(result);
      });

      test('Returns undefined when no model', () => {
        let result = element.findMethod('id1');
        assert.isUndefined(result);
      });
    });

    suite('_computeMethodModel()', () => {
      suiteSetup(() => {
        element = fixture('Basic');
      });

      test('Finds method by id', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch/post';
        const result = element._computeMethodModel(amf, id);
        assert.typeOf(result, 'object');
        assert.equal(result['@id'], id);
      });

      test('Returns undefined for enpoing id', () => {
        const id = API_ROOT + '%2Ffiles%2F%7BfileId%7D%2Ftouch';
        const result = element._computeMethodModel(amf, id);
        assert.isUndefined(result);
      });
    });

    suite('Basic computations', () => {
      suiteSetup(() => {
        element = fixture('Basic');
        element.amfModel = amf;
        element.selected = API_ROOT + '%2Ffiles/post';
      });

      test('_methodModel is computed', () => {
        assert.typeOf(element._methodModel, 'object');
      });

      test('httpMethod is computed', () => {
        assert.equal(element.httpMethod, 'post');
      });

      test('securedBy is computed', () => {
        assert.typeOf(element.securedBy, 'array');
      });

      test('apiHeaders is computed', () => {
        assert.typeOf(element.apiHeaders, 'array');
      });

      test('apiPayload is computed', () => {
        assert.typeOf(element.apiPayload, 'array');
      });

      test('isPayloadRequest is computed', () => {
        assert.isTrue(element.isPayloadRequest);
      });

      test('authNotRequired is set', () => {
        assert.isFalse(element.authNotRequired);
      });

      test('Changing selection to "undefined" clears the result', () => {
        element.selected = undefined;
        assert.isUndefined(element._methodModel);
        assert.isUndefined(element.httpMethod);
        assert.isUndefined(element.securedBy);
        assert.isUndefined(element.apiHeaders);
        assert.isUndefined(element.apiPayload);
      });
    });

    suite('View control', () => {
      function dataSetup(id, fix) {
        return new Promise((resolve) => {
          element = fixture(fix || 'Basic');
          element.amfModel = amf;
          element.selected = id;
          flush(() => resolve());
        });
      }

      test('Authorization tab is rendered', () => {
        return dataSetup(API_ROOT + '%2Ffiles/post')
        .then(() => {
          const panel = element.shadowRoot.querySelector('authorization-panel');
          const display = getComputedStyle(panel).display;
          assert.notEqual(display, 'none');
        });
      });

      test('Body tab is rendered', () => {
        return dataSetup(API_ROOT + '%2Ffiles/post')
        .then(() => {
          element.selectedTab = 3;
          assert.isTrue(element.isPayloadRequest);
          const panel = element.shadowRoot.querySelector('api-body-editor');
          const display = getComputedStyle(panel).display;
          assert.notEqual(display, 'none');
        });
      });

      test('api-url-editor is rendered', () => {
        return dataSetup(API_ROOT + '%2Ffiles/post')
        .then(() => {
          const panel = element.shadowRoot.querySelector('.url-editor');
          const display = getComputedStyle(panel).display;
          assert.notEqual(display, 'none');
        });
      });

      test('api-url-editor is not rendered when noUrlEditor', () => {
        return dataSetup(API_ROOT + '%2Ffiles/post', 'NoUrl')
        .then(() => {
          const panel = element.shadowRoot.querySelector('.url-editor');
          const display = getComputedStyle(panel).display;
          assert.equal(display, 'none');
        });
      });

      test('Computes URL when noUrlEditor', () => {
        return dataSetup(API_ROOT + '%2Ffiles/post', 'NoUrl')
        .then(() => {
          assert.equal(element.url, 'https://www.googleapis.com/drive/v2/files?uploadType=multipart&visibility=DEFAULT');
        });
      });
    });

    // test('instantiating the element with default properties works', () => {
    //   const element = fixture('BasicTestFixture');
    //   assert.equal(element.prop1, 'api-request-editor');
    //   const elementShadowRoot = element.shadowRoot;
    //   const elementHeader = elementShadowRoot.querySelector('h2');
    //   assert.equal(elementHeader.innerHTML, 'Hello api-request-editor!');
    // });
  });
  </script>
</body>
</html>
